<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
          src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
<title>Amal Mehta, Jason Zou, Srikar Boinapally, Jonathan Pan  |  CS 184</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="style.css" media="screen" />
</head>

<style>
    body {
      padding: 50px;
      width: 1000px;
      margin: auto;
      text-align: left;
      font-weight: 300;
      font-family: 'Open Sans', sans-serif;
      color: #121212;
    }
    h1 {
      font-size:40px;
      margin: 10px;
    }
    h2 {
      font-size: 35px;
      margin: 10px;
    }
    h3 {
      font-size: 30px;
    }

    h4 {
      font-size: 23px;
    }
    h1, h2, h3, h4 {
      font-family: 'Source Sans Pro', sans-serif;
      font-weight: normal;
    }

    p {
      font-size:20px;
    }

    .code {
        font-family: 'Courier New';
        background-color: #C0C0C0 ;
        font-size: 14px;
      }

  </style>

<body>

    <h1 align="middle">CS184: Computer Graphics and Imaging, Spring 2021</h1>
    <h1 align="middle">Final Project: Waterfall Simulation</h1>
    <h3 align="middle">Amal Mehta, Jason Zou, Jonathan Pan, Srikar Boinapally </h2>

    <h3 align="middle"><i>Abstract</i></h3>
      <p>Simulating waterfalls accurately is a challenging technical task, but can produce aesthetically pleasing results. Waterfall simulations can add to the user experience in gaming and VR/AR applications. The technical tasks and contributions for this waterfall simulation involved implementing physics equations from 
        literature to calculate particle positions, optimizing of simulation calculations, scene generation, and surface reconstruction. In the end we generated a waterfall scene with 200,000 particles.
      </p>
      
    <h3 align="middle"><i>Technical Approach</i></h3>
    <p>We based our code off of Project 4. The first step we took was isolate each of the individual pointmasses.</p>
    <h4 align="middle">Smoothed Particle Hydrodynamics (SPH) </h4>
    <p>For the simulation, we need to calculate the position of each particle at each time step. 
      The paper <a href="https://www.scitepress.org/papers/2018/68965/68965.pdf">Particle based Waterfall Simulation with Spray Cloud Emerging from
        Basin</a> <b>[1]</b> helped guide the governing equations we used for particle dynamics, and the overall structure of the waterfall. In particular, the 
      waterfall was divided up into a water stream, splashing spray, and spray cloud. Each of these components had different physical dynamics. </p>

        <p>For the <b>water stream</b>, we used Navier-Stokes to determine the acceleration of the falling particle. \[\frac{\partial u}{\partial t} = -\frac{1}{\rho}\nabla p + v\nabla^2 u + f \]
          Here \(u\) is velocity, \(t\) is time, \(\rho\) is density, \(p\) is pressure, \(v\) is viscosity and \(f\) is external acceleration. \(\nabla p\) represents the force density field due to pressure, \(v \nabla^2 u \) represents the force density field due to viscosity, and \(f\) represents external forces such as gravity, air resistance, or user interaction. In our case, we are simply using gravity. </p>

        <p>As part of SPH, each physical quanitity (i.e. density, pressure field, viscosity field) corresponding to an individual particle varies with time based on its neighbouring particles. The equations we use to calculate them follows <b>[2]</b>, which includes slight modifications to the traditional SPH quantity updates in order to make the forces symmetrical. These are defined as follows, where j denotes a neighboring particle of i:

          \[\rho(x_i) = \sum_{j} m_jW(x_i-x_j, h)\]
            \[\nabla p(x_i) = \sum_{j}m_j\frac{p_i + p_j}{2\rho_j}\nabla W(x_i-x_j, h)\] 
            \[\nabla u^2(x_i) = \sum_{j} m_j \frac{v_j - v_i}{\rho_j} \nabla^2 W(x_i-x_j, h)\]

          As this summation of neighbors for each particle introduces a major computational bottleneck, we detail our method of neighborhood search in the optimization section below. 
          <p>\(W\) corresponds to a kernel smoothing function, of which there are many possible choices. For our project, we use the kernels defined in <b>[2]</b> based on their reported success and popularity, with a slight modification to the gradient kernel based on <b>[3]</b> that we found to produce more numerically stable results for our particular scene setups. </p>
          
          \[W(r,h) =
                   \frac{315}{64\pi h^9} \begin{cases}
                            (h^2-r^2)^3,  & \text{if $0 \le r \le h$} \\
                            0, & \text{otherwise}
                            \end{cases}\]

          \[\nabla W(r,h) =
          -\frac{45}{ \pi h^4}r \begin{cases}
                    (h-r)^2,  & \text{if $0 \le r \le h$} \\
                    0, & \text{otherwise}
                    \end{cases}\]         

          \[\nabla^2 W(r,h) =
          \frac{45}{\pi h^6} \begin{cases}
                    (h-r),  & \text{if $0 \le r \le h$} \\
                    0, & \text{otherwise}
                    \end{cases}\]                   

          <p>
          Gravity and air resistance are considered when computing the external acceleration \(f\) and can be computed as:
          \[f = g + \frac{1}{\rho_p V_p}F_{air}\]
          \[F_{air} = \frac{1}{2} \pi (\frac{D_p}{2})^2 \rho_a C_r |u_p| u_p\]

          \(g\) is gravity, \(\rho_p\), \(V_p\), \(D_p\), and \(u_p\) are the density, volume, diameter, and velocity of a particle. \(\rho_a\) and \(C_r\) are the density of air 
          and coefficient of air resistance. </p>


        </p>

        <p>For the <b>spray cloud</b> particles, we use a modified Navier-Stokes as follows:
          
          \[\frac{\partial u}{\partial t} = -(u \cdot \nabla) u  -\frac{1}{\rho}\nabla p + v\nabla^2 u + f \]
          
          \[\nabla \cdot u = 0\]

          Vapor density was calculated by:

          \[\rho_v = 1.293*\frac{273.15}{273.15 + T} \frac{p}{1013.25}(1-0.378 \frac{e}{p})\]
         </p>

         <p>After calculating the accelerations of the particles, we used verlet integration to determine the particle position update equation.
            \[x_{t+dt} = x_t + (1-d)*(x_t-x_{t-dt})+ a_t*dt^2 \]

         </p>

    <h4 align="middle">Optimization</h4>
    <p>One challenge with this project was ensuring that the simulation calculations were computed quickly. We utilized OpenMP to speed up parallelizable sections
      of the code.</p>

    <p>To compute the Navier Stokes equation, we need to determine the neighboring particles within a specified neighboorhood radius for every particle. Initially we utilized
      the CompactNSearch library for neighborhood search, but found that it was too computationally expensive. It would crash our machines if ran in conjunction with 
      the navier stokes computation. Thinking back to project 4, we looked into devising a spatial hashing approach. We found that it would be too inaccurate for 
      our purposes to use vanilla spatial hashing from project 4 so we utilized a method from <a href="https://cs.nyu.edu/~jihun/paper/sca2010.pdf">Reconstructing Surfaces of Particle-Based Fluids
        Using Anisotropic Kernels</a> <b>[4]</b>. The method works by computing an axis aligned bounding box for the ellipsoid associated with each particle. The ellipsoid is 
        calculated using an anisotropic kernel. The scene space is divided into grid cells (number and size of grid cells determined by a constant parameter). Whichever cells the bounding box intersects 
        are the ones the particle is mapped to in the spatial hashmap. Our hash functions hashes the grid cell which contains the particle with a linear formula 
        using large prime coefficients to avoid collisions.</p>
     <p>   
        Prior to implementing the ansiotropic kernel and constructing the bounding box, we used a sphere instead of the ellipsoid in order to get something up and running quickly. We computed the distance between 
        a point and a grid cell to be \[d = \sqrt{\max(0, |x| -1)^2 + \max(0, |y|-1)^2 + \max(0, |z| - 1)^2} \] for a point with coordinates \(x\), \(y\), \(z\). 
     </p>

     <!--<p>Another method we tried</p> Jason, you can add the other method here if you want -->

    <h4 align="middle">Surface Reconstruction</h4>

    <p>

    </p>
    
    <h3 align="middle"><i>Results</i></h3>
    
    </p>
    <h3 align="middle"><i>Lessons Learned</i></h3>
    <p>It was interesting to take what we learned from the cloth simulation project and expand upon it by implementing ideas from literature. We were able to peek even further behind the layers of abstraction in the 
      codebase to implement what we wanted. While researching the various methods, we practiced the skill of deciphering papers and gained a deeper understanding of the physics behind how fluids work in the physical world. 
      We also had to deal with ambiguities in the paper so that we could use the methods in our scenario, which required a lot of communication between the group members. Overall, we learned the complexities that go into creating a 
      realistic waterfall simulation, especially in the surface reconstruction component. 
    </p>
    <h3 align="middle"><i>Team Member Contributions</i></h3>
    <p>Amal Mehta: reading papers to find pertinent information for the project, implementing the optimization components, writing the final report and website.</p>
    <p>Jason Zou: </p>
    <p>Jonathan Pan:</p>
    <p>Srikar Boinapally: </p>

    <h3 align="middle"><i>References</i></h3>
    <p><b>[1]</b>: https://www.scitepress.org/papers/2018/68965/68965.pdf</p>
    <p><b>[2]</b>: https://matthias-research.github.io/pages/publications/sca03.pdf</p>
    <p><b>[3]</b>: https://elrnv.com/cs888/cs888proj.pdf</p>
    <p><b>[4]</b>: https://cs.nyu.edu/~jihun/paper/sca2010.pdf </p>
    <p>We started from the project 4 skeleton, which can be found here: <a href="https://github.com/cal-cs184-student/p4-clothsim-sp21-alexbuckley4">Project 4 Skeleton</a></p>
</body>
</html>




